## Automotus Prototype Summary

The items I prioritized are defined in the `MVP_PLAN.md` file using the MoSCoW analysis format. Using this framework I identified key structural requirements necessary to create a working MVP demo of core items that Must be developed for an MVP solution including: App state management, API requests & mocking, mobile-first layouts, and the need to present data in a clear format for the user. If time permitted, I intended to also begin work on the Should Have category, however I had about 30 minutes left before the 3-hour mark and decided to review the work I had done and submit it. I decided to avoid working on the Could Have & Won't Have categories because they either represented too much work given the time constraints (e.g. a map view) or they represented work that was extraneous to the requirements presented in the prompt.

I assumed the user needed specific information presented in an easy-to-digest format via data aggregation, such as listing current occupancy and maximum occupancy together to make it more clear how full a given zone is at a glance. Another way of accomplishing this could have been with a percent-full calculation, however that seemed to be a less attractive option given the size of parking zones would typically be low in the locations currently supported in Philadelphia where I based my demo. I also assumed the user would prefer to see a prioritized list of parking zones with additional UI signals such as color to quickly identify parking zones with the most violations (top of list & red border) or parking zones with no violations (bottom of list & green). A future enhancement to this choice would be to add sorting options such as sort by proximity, sort by oldest violation, or compound sorts & filters such as by zone type.

I approached the API design by focusing on two primary methods of fetching data: complete list with 1 level of data included & a detail endpoint which would include nested data. I leveraged Github Copilot to generate my API mocking code to afford myself more time to set up the UI demo and did not verify if this was working as expected, however a cursory look at the generated code does appear to follow this paradigm. I chose this pattern because it helps keep request responses smaller and faster while allowing the mobile app to fetch increasing detail as needed when the user begins navigating to nested screens. While this adds additional complexity to typing the API fetch code and being more aware of where the data is coming from, my experience in the past has been that as applications scale and track more data smaller, more frequent requests tend to be preferred over longer-running, more complete data requests.

If I had an additional 2-3 hours to work on this prototype I would begin creating a few core, reusable components to make rapidly prototyping screens easier and more consistent. A few that come to mind include typography components for body text & headings, a card for containing data, buttons & links, as well as animations when navigating between screens to make the app feel more like a mobile experience while existing as a web app. I would have also finished building out additional pages to display vehicle data, alerts, and parking enforcement officer activity logs. If I had an hour remaining after completing the aforementioned tasks, I would have made an effort to implement a primitive map-view using [React Map GL](https://visgl.github.io/react-map-gl/) or link to a map app to assist in giving the PEO directions to the zones they are trying to find.

I appreciate the opportunity to work on this coding challenge and look forward to presenting it to the team!
